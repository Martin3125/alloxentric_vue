from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, EmailStr, constr
from pymongo import MongoClient
from bson.objectid import ObjectId
from fastapi.middleware.cors import CORSMiddleware
from passlib.context import CryptContext
from typing import List
from pydantic import BaseModel, Field
from datetime import datetime
from pydantic import BaseModel, Field, validator
from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import date, time, datetime

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],  # Permitir todos los métodos (GET, POST, etc.)
    allow_headers=["*"],
)

# Conexión a MongoDB
client = MongoClient("mongodb://localhost:27017/")
db = client["alloxentric"]
users_collection = db["usuarios"]
# accioncobranza_collection = db["AccionCobranza"]
cobranza_collection = db["Cobranza"]
Sin_acciones_collection = db["Sin_acciones"] 
acciones_collection = db["AccionCobranza"]

# Definición del modelo de usuario
class User(BaseModel):
    nombre: constr(max_length=16)
    email: EmailStr
    pwd: constr(min_length=6, max_length=12)

class LoginUser(BaseModel):
    email: EmailStr
    pwd: constr(min_length=6, max_length=12)



# class Sin_acciones(BaseModel):
#     nombre_cobranza: constr(max_length=16)
#     fecha_cobranza: datetime
#     intervalo: int
#     valor: float

# Model for individual actions
class AccionCobranza(BaseModel):
    Id_accion: Optional[str]  # Optional because it will be generated by MongoDB
    accion_cobranza: str
    fecha_cobranza: str
    intervalo: int
    valor: float


class Deudor(BaseModel):
    ID_deudor: int
    nombre_deudor: str
    numtelefono: str
    email: EmailStr
    Deuda: float

class Historial(BaseModel):
    Id_documento: int
    Nnombre: str
    fecha: date

class ProcesamientoP(BaseModel):
    Id_procesamiento: int
    nombre: str
    fecha: date
    hora: time
class Resultados(BaseModel):
    ID: int
    nombre_documento: str
    fecha: date
    registro_gente: float
    accion: str
    gente_contactar: float

class Reporte(BaseModel):
    ID_deudor: int
    nombre_deudor: str 
    accion: str  
    fecha_envio: date
    intervalo: str 
    fecha_estimada: date
    demora: str  
    fecha_real: date
    debe_pagar: float
    valor_pagar: float

class KMeansModel(BaseModel):
    model_name: str  
    model_file: str
    created_at: datetime

class Pago(BaseModel):
    id_pago: int  
    user: str
    nombreEs: str  
    h_inicio: str  
    fecha_Pago: str 
    totalPago: str 

#Endpoint de registro
@app.post("/api/register")
async def register_user(user: User):
    if users_collection.find_one({"email": user.email}):
        raise HTTPException(status_code=400, detail="El correo ya está registrado")
    # Hash de la contraseña
    hashed_pwd = pwd_context.hash(user.pwd)
    new_user = {
        "nombre": user.nombre,
        "email": user.email,
        "pwd": hashed_pwd,
        "tipo_usuario": False  # Asumiendo que es un usuario normal por defecto
    }

    users_collection.insert_one(new_user)
    return {"success": True, "message": "Usuario registrado exitosamente"}

#Endpoint de login
@app.post("/api/login")
async def login_user(user: LoginUser):
    # Verificar si el usuario existe
    user_record = users_collection.find_one({"email": user.email})
    if not user_record:
        raise HTTPException(status_code=400, detail="Correo o contraseña incorrectos")

    # Verificar la contraseña
    if not pwd_context.verify(user.pwd, user_record["pwd"]):
        raise HTTPException(status_code=400, detail="Correo o contraseña incorrectos")

    return {"success": True, "message": "Inicio de sesión exitoso"}


#Endpoint de cobranza
@app.post("/api/acciones")
async def register_or_update_accion(acciones: List[AccionCobranza]):
    for accion in acciones:
        # Check if action with the same `accion_cobranza` and `Id_accion` exists
        existing_accion = acciones_collection.find_one({
            "accion_cobranza": accion.accion_cobranza,
            "Id_accion": accion.Id_accion
        })
        
        if existing_accion:
            # Update existing record
            result = acciones_collection.update_one(
                {"_id": existing_accion["_id"]},
                {"$set": {
                    "fecha_cobranza": accion.fecha_cobranza,
                    "intervalo": accion.intervalo,
                    "valor": accion.valor
                }}
            )
            if result.modified_count == 0:
                raise HTTPException(status_code=400, detail="No se pudo actualizar el registro")
        else:
            # Insert new record
            new_accion = accion.dict()
            del new_accion["Id_accion"]  # Remove Id_accion as it should not be in the document
            acciones_collection.insert_one(new_accion)
    
    return {"success": True, "message": "Acciones registradas exitosamente"}


# base de los demas endpoints 

# Simulación de base de datos en memoria
documentos_db = {}
procesamientos_db = {}
resultados_db = {}

@app.get("/ejemplo/")
async def ejemplo():
    respuesta = dict(mensaje="Éxito", codigo=200)
    return respuesta

# Procesamiento - POST: Iniciar procesamiento de documentos subidos
@app.post("/api/procesamiento", response_model=str)
def iniciar_procesamiento(documentos_ids: List[str]):
    if not documentos_ids:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="IDs de documentos faltantes.")
    
    # Verificar si todos los documentos existen
    for doc_id in documentos_ids:
        if doc_id not in documentos_db:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Documentos no encontrados.")
    
    # Simulación de procesamiento
    proceso_id = "proc_" + "_".join(documentos_ids)
    procesamientos_db[proceso_id] = {"documentos": documentos_ids}
    
    return f"ID del proceso iniciado: {proceso_id}"

# Procesamiento (Resultados) - GET: Resultados del procesamiento ejecutado
@app.get("/procesamiento/{proceso_id}", response_model=dict)
def obtener_resultados_procesamiento(proceso_id: str):
    if proceso_id not in procesamientos_db:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Procesamiento no encontrado.")
    
    try:
        resultados = procesamientos_db[proceso_id]
        return resultados
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Internal Server Error - Error del servidor.")

# Cargar resultados del período anterior en los Directorios - GET
@app.get("/resultados/periodo-anterior/directorios/{resultado_id}", response_model=str)
def cargar_resultados_directorios(resultado_id: str):
    if resultado_id not in resultados_db:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Resultados no encontrados.")
    
    # Simulación de carga de resultados en directorios
    return f"Carga de los resultados realizados en el periodo anterior según el directorio: {resultado_id}"

# Cargar resultados del período anterior para los Archivos - GET
@app.get("/resultados/periodo-anterior/archivos/{resultado_id}", response_model=str)
def cargar_resultados_archivos(resultado_id: str):
    if resultado_id not in resultados_db:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Resultados no encontrados.")
    
    # Simulación de carga de resultados en archivos
    return f"Carga de los resultados realizados en el periodo anterior según el archivo: {resultado_id}"

# Generar resultados del período - GET
@app.get("/resultados/generar/{resultado_id}", response_model=List[dict])
def generar_resultados(resultado_id: str):
    if resultado_id not in resultados_db:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Resultados no encontrados.")
    
    try:
        # Simulación de generación de resultados
        resultados = [{"id": resultado_id, "resultado": "Datos del procesamiento generado"}]
        return resultados
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Internal Server Error - Error del servidor.")

# Informes (Reportes de la última carga) - GET
@app.get("/informes/ultima-carga/{reporte_id}", response_model=str)
def visualizar_reporte_ultima_carga(reporte_id: str):
    if reporte_id not in resultados_db:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Resultados no encontrados.")
    
    # Simulación de visualización de reportes de la última carga
    return f"Visualización de los reportes de la última carga: {reporte_id}"

# Informes (Reportes de desempeño) - GET
@app.get("/informes/desempeno/{deudor_id}", response_model=str)
def visualizar_reporte_desempeno(deudor_id: str):
    if deudor_id not in resultados_db:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Deudor no encontrado.")
    
    # Simulación de visualización de reporte de desempeño
    return f"Visualización del desempeño del deudor con ID: {deudor_id}"